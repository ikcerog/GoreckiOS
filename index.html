<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GoreckiOS - Web Desktop Simulator (Interactive)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght400&display=swap" rel="stylesheet">
    
    <!-- Tone.js CDN for sound effects -->
    <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
    
    <!-- Firebase SDK Imports (Module style for modern JS) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // Import Firestore functions and expose them globally
        import { getFirestore, doc, setDoc, getDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase Variables (provided by the environment)
        window.__app_id = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        window.firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        window.__initial_auth_token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase and expose core services globally
        if (Object.keys(window.firebaseConfig).length > 0) {
            const app = initializeApp(window.firebaseConfig);
            window.db = getFirestore(app);
            window.auth = getAuth(app);
            
            // Expose the necessary Firestore functions to the global scope (window)
            window.firestoreDoc = doc;
            window.firestoreSetDoc = setDoc;
            window.firestoreGetDoc = getDoc;
            
            // Set logging for debugging Firestore operations
            setLogLevel('Debug'); 
        } else {
            console.error("Firebase config is missing. Persistence will not work.");
        }
        
        // Asynchronous Authentication Function
        window.initFirebaseAuth = async () => {
            try {
                if (window.__initial_auth_token) {
                    await signInWithCustomToken(window.auth, window.__initial_auth_token);
                } else {
                    await signInAnonymously(window.auth);
                }
                // Once authenticated, get the user ID
                window.userId = window.auth.currentUser.uid;
                console.log("Firebase Auth successful. User ID:", window.userId);
            } catch (error) {
                console.error("Firebase Authentication Error:", error);
                // Fallback to a random ID if auth fails, but persistence won't work correctly.
                window.userId = crypto.randomUUID(); 
            }
        };

        // Initialize the desktop once authentication is ready
        window.initFirebaseAuth().then(window.initDesktop); 

    </script>
    
    <style>
        /* Custom Configuration for Tailwind */
        :root {
            --arch-cyan: #00bcd4; /* A vibrant teal/cyan */
        }
        
        /* Apply Inter font family by default, use JetBrains Mono for terminal-like text */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; 
            margin: 0;
            padding: 0;
        }
        
        .arch-bar {
            background-color: #171717; 
            color: #f3f4f6;
            border-bottom: 2px solid var(--arch-cyan);
            height: 32px;
            user-select: none;
        }

        /* 90s Minimalist Diagonal Stripe Background */
        .desktop-bg {
            background-color: #1a1a1a; 
            /* Subtle diagonal stripes: dark gray (#212121) on background (#1a1a1a) */
            background-image: linear-gradient(
                -45deg, 
                #212121 25%, 
                transparent 25%, 
                transparent 50%, 
                #212121 50%, 
                #212121 75%, 
                transparent 75%, 
                transparent
            );
            background-size: 20px 20px;
        }
        
        /* Styling for the i3-gaps inspired windows */
        .i3-window {
            position: absolute; 
            border: 2px solid #333;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease-out; 
            min-width: 200px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            resize: both; 
            overflow: hidden; 
        }
        
        /* Class to disable transition during drag */
        .i3-window.no-transition {
            transition: none !important;
        }
        
        .window-header {
            cursor: grab;
            background-color: #262626; 
            border-bottom: 1px solid #3f3f46;
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .window-title {
            color: var(--arch-cyan);
            font-weight: 600;
            font-size: 0.8rem;
        }

        .window-controls > button {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-left: 4px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .window-controls > button:hover {
            opacity: 1;
        }

        .close-btn { background-color: #ef4444; } 
        .minimize-btn { background-color: #f59e0b; } 
        .maximize-btn { background-color: #10b981; } 

        .window-content {
            background-color: #212121; 
            flex-grow: 1;
            color: #d1d5db;
            overflow-y: auto; 
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            display: flex;
            flex-direction: column;
            padding: 8px;
        }

        /* Terminal Specific Styles */
        #terminal-output {
            flex-grow: 1;
            white-space: pre-wrap; 
            overflow-y: auto;
            padding-bottom: 12px;
        }

        #terminal-input-container {
            display: flex;
            align-items: center;
            padding-top: 4px;
        }

        #terminal-input {
            background: transparent;
            border: none;
            outline: none;
            color: #f3f4f6;
            flex-grow: 1;
            margin-left: 4px;
            caret-color: var(--arch-cyan);
        }

        /* Focus state: Border brightens */
        .i3-window.focused {
            border-color: var(--arch-cyan);
            box-shadow: 0 0 15px rgba(0, 189, 212, 0.7); 
            z-index: 100; 
        }
        
        .prompt {
            color: #93c5fd; 
        }

        /* Initial Tiling */
        #desktop {
            position: relative;
            width: 100vw;
            height: calc(100vh - 32px); 
        }
        
        /* CMatrix Canvas ensures no padding/margin from window content */
        .cmatrix-container {
            padding: 0;
            margin: 0;
            width: 100%;
            height: 100%;
        }

        #matrix-canvas {
            display: block;
            background-color: #0a0a0a;
        }
        
        /* Textarea style for config window */
        #config-textarea {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }
    </style>
</head>

<body class="desktop-bg">

    <!-- i3-status Bar Simulation -->
    <div class="arch-bar flex justify-between items-center px-4 shadow-lg z-20">
        <!-- Workspace indicators -->
        <div id="workspace-bar" class="flex space-x-2 text-xs">
            <span class="workspace-btn px-2 py-0.5 rounded-sm bg-cyan-600 text-gray-900 font-bold cursor-pointer" data-workspace-id="1">1</span>
            <span class="workspace-btn px-2 py-0.5 rounded-sm hover:bg-gray-700 transition duration-150 cursor-pointer" data-workspace-id="2">2</span>
            <span class="workspace-btn px-2 py-0.5 rounded-sm hover:bg-gray-700 transition duration-150 cursor-pointer" data-workspace-id="3">3</span>
            <span class="workspace-btn px-2 py-0.5 rounded-sm hover:bg-gray-700 transition duration-150 cursor-pointer" data-workspace-id="4">4</span>
        </div>

        <!-- System Status (Minimal) -->
        <div class="flex space-x-4 text-xs font-mono">
            <span id="datetime-display" class="text-cyan-400 font-semibold"></span>
        </div>
    </div>

    <!-- Desktop Area -->
    <div id="desktop" class="relative">
        <!-- Windows will be injected here by JavaScript -->
    </div>

    <script>
        // --- Gemini API Configuration ---
        // IMPORTANT: REPLACE "YOUR_API_KEY_HERE" WITH your actual Gemini API Key Key string.
        const API_KEY = "YOUR_API_KEY_HERE"; 
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        
        // System instruction to define the persona of the shell
        const SHELL_PROMPT = `You are a sarcastic, witty, and extremely knowledgeable Arch Linux shell assistant named 'GoreckiOS'. Your responses must mimic Linux terminal output.
        
        1. Format your output as simple plain text, simulating a terminal response.
        2. NEVER use markdown formatting like **bold** or *italics*.
        3. Do not include the user's prompt or the shell prompt in your response.
        4. If asked a command that doesn't exist (like 'run_app'), give a witty error message, maybe referencing 'pacman' or 'AUR'.
        5. Answer questions about Linux, coding, configuration, or general knowledge with a superior, Arch-user attitude.
        6. Keep responses concise, typically 2-4 lines of output.
        
        Example Output for 'pacman -Syu':
        :: Synchronizing package databases...
        core is up to date
        extra is up to date
        :: Arch is up to date. You expected anything less?`;

        // --- Desktop Environment Configuration ---
        const GAP_SIZE = 12; 
        
        // Default content for the editable config file
        let configContent = `# i3-gaps config file (Persistence enabled!)

set $mod Mod4

# gaps
gaps inner 10
gaps outer 5

# Start terminal
bindsym $mod+Return exec i3-sensible-terminal

# Set background:
# exec_always feh --bg-fill /path/to/wallpaper.jpg

# End of file`;
        
        // Configuration for all workspaces
        const WORKSPACES = {
            '1': [
                { id: 'w1', title: 'Terminal - bash (GoreckiOS Shell)', type: 'terminal', ratio: [0, 0, 70, 100], isFloating: false, content: null }, 
                { id: 'w2', title: 'neovim /etc/config.txt', type: 'text', ratio: [70, 0, 30, 50], isFloating: false, content: null },
                { id: 'w3', title: 'Background Process: Matrix', type: 'cmatrix-window', ratio: [70, 50, 30, 50], isFloating: false, content: null } 
            ],
            '2': [
                // Example of a floating window for a different task on Workspace 2
                { id: 'w4', title: 'Project Alpha - Documentation', type: 'text', ratio: [10, 10, 80, 80], isFloating: true, content: 'This is a floating document on Workspace 2. Edits here are saved.' } 
            ],
            '3': [], // Empty workspace
            '4': []  // Empty workspace
        };

        // State Management
        let allWindows = {}; // Stores all instantiated window objects across all workspaces
        let windows = [];    // Stores currently visible window objects (for tiling/rendering)
        let focusedWindow = null;
        let currentWorkspace = '1';
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let terminalHistory = []; 
        let successSynth = null; 
        
        // Elements
        const desktopEl = document.getElementById('desktop');
        const datetimeEl = document.getElementById('datetime-display');
        const getWorkspaceBar = () => document.getElementById('workspace-bar');

        // --- Core Utility Functions (Including API and Tiling) ---
        
        /** Retrieves the Firestore document reference for desktop state. */
        function getStateDocRef() {
            // Check for the globally exposed functions and objects
            if (!window.db || !window.userId || !window.firestoreDoc) return null;
            
            // Private data path for persistence: /artifacts/{appId}/users/{userId}/desktop_state/config
            return window.firestoreDoc(window.db, 'artifacts', window.__app_id, 'users', window.userId, 'desktop_state', 'config');
        }

        /** Saves the current application state to Firestore. */
        async function saveState() {
            const stateDocRef = getStateDocRef();
            if (!stateDocRef || !window.firestoreSetDoc) return;

            // 1. Ensure the currently focused text window's content is saved to allWindows
            if (focusedWindow) {
                const textarea = focusedWindow.querySelector('#config-textarea');
                if (textarea) {
                    allWindows[focusedWindow.id].config.content = textarea.value;
                }
            }
            
            // 2. Prepare data for storage: only store persistent fields
            const dataToSave = {};
            
            // Transform allWindows into a simpler, storable format
            Object.keys(allWindows).forEach(winId => {
                const win = allWindows[winId];
                dataToSave[winId] = {
                    content: win.config.content || '',
                    isFloating: win.isFloating,
                    lastMetrics: win.lastMetrics,
                    currentWorkspace: win.config.currentWorkspace || '1' // Track which workspace a window belongs to
                };
            });
            
            try {
                await window.firestoreSetDoc(stateDocRef, {
                    timestamp: new Date().toISOString(),
                    windowStates: dataToSave
                }, { merge: true });
            } catch (error) {
                console.error("Failed to save state to Firestore:", error);
            }
        }
        
        /** Loads the application state from Firestore. */
        async function loadState() {
            const stateDocRef = getStateDocRef();
            if (!stateDocRef || !window.firestoreGetDoc) return null;

            try {
                const docSnap = await window.firestoreGetDoc(stateDocRef);
                if (docSnap.exists()) {
                    return docSnap.data().windowStates;
                }
            } catch (error) {
                console.error("Failed to load state from Firestore:", error);
            }
            return null;
        }


        /** Retry logic for API calls using exponential backoff. */
        async function fetchWithBackoff(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                // If API_KEY is missing, immediately fail with a helpful error
                if (API_KEY === "YOUR_API_KEY_HERE" || !API_KEY) {
                    throw new Error("API Key Missing. Please insert your key in the HTML code.");
                }

                try {
                    const response = await fetch(url, options);
                    if (response.status !== 429) return response; 
                } catch (error) {
                    console.error('Fetch attempt failed:', error);
                }
                const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
            throw new Error('API request failed after multiple retries.');
        }

        /** Plays a success tone using Tone.js. */
        function playSuccessTone() {
            if (!successSynth) return;
            successSynth.triggerAttackRelease("C4", "8n");
        }
        
        /** Plays a failure tone using Tone.js. */
        function playFailureTone() {
            if (!successSynth) return;
            successSynth.triggerAttackRelease("C2", "8n");
        }

        /** Updates the date and time display. */
        function updateDateTime() {
            const now = new Date();
            const date = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const time = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            datetimeEl.textContent = `[${date} | ${time}]`;
        }

        /** Calculates the position and size of a tiled window based on the ratio config. */
        function calculateTiledMetrics(ratio) {
            const desktopWidth = desktopEl.clientWidth;
            const desktopHeight = desktopEl.clientHeight;

            const [ratioX, ratioY, ratioW, ratioH] = ratio;

            let x = desktopWidth * (ratioX / 100);
            let y = desktopHeight * (ratioY / 100);
            let w = desktopWidth * (ratioW / 100);
            let h = desktopHeight * (ratioH / 100);

            // Apply Gaps
            if (ratioX === 0) x += GAP_SIZE;
            else x += (GAP_SIZE / 2);

            if (ratioY === 0) y += GAP_SIZE;
            else y += (GAP_SIZE / 2);

            if (ratioX === 0 && ratioX + ratioW === 100) w -= (GAP_SIZE * 2); 
            else if (ratioX === 0 || ratioX + ratioW === 100) w -= (GAP_SIZE * 1.5);
            else w -= GAP_SIZE;

            if (ratioY === 0 && ratioY + ratioH === 100) h -= (GAP_SIZE * 2); 
            else if (ratioY === 0 || ratioY + ratioH === 100) h -= (GAP_SIZE * 1.5);
            else h -= GAP_SIZE; 
            
            return {
                left: x,
                top: y,
                width: Math.max(200, w),
                height: Math.max(100, h)
            };
        }

        /** Applies calculated metrics to a window element. */
        function applyMetrics(windowEl, metrics) {
            windowEl.style.left = `${metrics.left}px`;
            windowEl.style.top = `${metrics.top}px`;
            windowEl.style.width = `${metrics.width}px`;
            windowEl.style.height = `${metrics.height}px`;
        }

        /** Rerenders all visible windows based on the current desktop size. */
        function tileWindows() {
            windows.forEach(win => {
                // Only re-tile if the window is NOT floating
                if (!win.el.classList.contains('hidden') && !win.isFloating) {
                    const metrics = calculateTiledMetrics(win.config.ratio);
                    applyMetrics(win.el, metrics);
                    win.lastMetrics = metrics; // Update last metrics for reference
                    
                    // Special case for matrix canvas resize
                    if (win.config.type === 'cmatrix-window') {
                        const canvas = win.el.querySelector('#matrix-canvas');
                        if (canvas) {
                            // CMatrix needs canvas width/height attributes set
                            // Adjusting for window content padding (8px on each side = 16px)
                            canvas.width = metrics.width - 16; 
                            // Header (32px) + Content top padding (8px) + Content bottom padding (8px)
                            canvas.height = metrics.height - (32 + 16); 
                        }
                    }
                }
            });
        }

        /** Sets the focus state for a window and handles content saving/loading. */
        function focusWindow(windowEl) {
            // 1. Save content/state of the previously focused window
            if (focusedWindow) {
                focusedWindow.classList.remove('focused');
                const prevWinData = allWindows[focusedWindow.id];

                // Save content for text windows
                if (prevWinData && prevWinData.config.type === 'text') {
                    const textarea = focusedWindow.querySelector('#config-textarea');
                    if (textarea) {
                        prevWinData.config.content = textarea.value;
                    }
                }
                // Save window position/size (used for floating mode)
                prevWinData.lastMetrics = { 
                    width: focusedWindow.offsetWidth, 
                    height: focusedWindow.offsetHeight,
                    left: focusedWindow.offsetLeft,
                    top: focusedWindow.offsetTop
                };
                
                // Trigger a state save to Firestore
                saveState();
            }
            
            // 2. Set focus on the new window
            focusedWindow = windowEl;
            focusedWindow.classList.add('focused');
            
            // Bring to front
            let maxZIndex = 100;
            document.querySelectorAll('.i3-window:not(.focused)').forEach(el => {
                maxZIndex = Math.max(maxZIndex, parseInt(el.style.zIndex || 0));
            });
            windowEl.style.zIndex = maxZIndex + 1;
            
            // 3. Load content and set focus on input
            const winData = allWindows[windowEl.id];
            
            if (winData.config.type === 'terminal') {
                getTerminalElements()?.input?.focus();
            } else if (winData.config.type === 'text') {
                const textarea = windowEl.querySelector('#config-textarea');
                if (textarea) {
                    // Load content from winData (which was loaded from Firestore or default)
                    textarea.value = winData.config.content || ''; 
                    textarea.focus();
                }
            }
        }
        
        // --- CMatrix Effect Logic ---
        function createMatrixEffect(canvas) {
            const ctx = canvas.getContext('2d');
            const katakana = 'アァカサタナハマヤャラワガザダバパ';
            const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const numbers = '0123456789';
            const symbols = '!@#$%^&*()_+';
            const chars = (katakana + latin + numbers + symbols).split('');

            let fontSize = 16;
            let columns;
            let drops = [];
            
            function initializeMatrix() {
                const container = canvas.closest('.window-content');
                // Use offsetWidth/Height as the content div has padding
                canvas.width = container.offsetWidth; 
                canvas.height = container.offsetHeight; 

                columns = Math.floor(canvas.width / fontSize);
                drops = [];
                for (let x = 0; x < columns; x++) {
                    drops[x] = 1; 
                }
            }

            // Initial call
            initializeMatrix();

            // Setup ResizeObserver to automatically adjust canvas size
            const observer = new ResizeObserver(() => {
                initializeMatrix();
            });
            observer.observe(canvas.closest('.i3-window'));


            function draw() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#0f0'; 
                ctx.font = fontSize + 'px monospace';

                for (let i = 0; i < drops.length; i++) {
                    const text = chars[Math.floor(Math.random() * chars.length)];
                    const x = i * fontSize;
                    const y = drops[i] * fontSize;

                    ctx.fillText(text, x, y);

                    if (y > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }

                    drops[i]++;
                }
            }

            setInterval(draw, 33); 
        }

        // --- Terminal Interaction Logic ---

        const PROMPT_TEXT = '<span class="text-cyan-400">goreck-web</span><span class="text-white">@</span><span class="text-green-400">canvas</span>:<span class="text-blue-400">~</span>$ ';

        function getTerminalElements() {
            const terminalEl = document.getElementById('w1');
            if (!terminalEl || terminalEl.classList.contains('hidden')) return null;
            return {
                output: terminalEl.querySelector('#terminal-output'),
                input: terminalEl.querySelector('#terminal-input'),
                inputContainer: terminalEl.querySelector('#terminal-input-container'),
                windowEl: terminalEl
            };
        }
        
        /** Renders the current state of the terminal history. */
        function renderTerminalOutput() {
            const { output } = getTerminalElements();
            if (!output) return;

            output.innerHTML = terminalHistory.map(entry => {
                if (entry.role === 'user') {
                    return PROMPT_TEXT + entry.text;
                }
                return `<span class="text-gray-300">${entry.text.replace(/\n/g, '<br>')}</span>`; 
            }).join('<br>');
            
            output.scrollTop = output.scrollHeight;

            setTimeout(() => {
                getTerminalElements()?.input?.focus();
            }, 10); 
        }

        /** Handles the user submitting a command in the terminal. */
        async function handleCommand(e) {
            if (e.key !== 'Enter') return;
            const { input, output, inputContainer } = getTerminalElements();
            if (!input || input.disabled) return;
            
            const command = input.value.trim();
            if (command === '') {
                terminalHistory.push({ role: 'user', text: '' });
                renderTerminalOutput();
                return;
            }

            // 1. Add command to history and disable input
            terminalHistory.push({ role: 'user', text: command });
            input.value = '';
            input.disabled = true;
            inputContainer.classList.add('opacity-50');
            renderTerminalOutput();
            
            // 2. Add temporary loading indicator
            const loadingIndex = terminalHistory.length;
            terminalHistory.push({ role: 'llm', text: '<span class="text-yellow-400">loading...</span>' });
            renderTerminalOutput();
            
            let success = false;
            try {
                // 3. Construct API Payload
                const payload = {
                    contents: [{ parts: [{ text: command }] }],
                    systemInstruction: { parts: [{ text: SHELL_PROMPT }] },
                    generationConfig: {
                        temperature: 0.7 
                    }
                };

                // 4. Fetch response using backoff
                const response = await fetchWithBackoff(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "Error: Failed to get response from server.";

                // 5. Update history with LLM response
                terminalHistory[loadingIndex] = { role: 'llm', text: text };
                success = true; // Mark as successful
            } catch (error) {
                console.error('API or Fetch Error:', error);
                const errorMessage = error.message.includes("API Key Missing") 
                    ? `Error: API Key Missing. Please insert your key in the 'index.html' file.`
                    : `Error: Connection failed. Check network or API key setup.`;
                terminalHistory[loadingIndex] = { role: 'llm', text: errorMessage };
                success = false; // Mark as failed
            } finally {
                // 6. Play sound and re-enable input and render final output
                if (success) {
                    playSuccessTone();
                } else {
                    playFailureTone();
                }
                
                input.disabled = false;
                inputContainer.classList.remove('opacity-50');
                renderTerminalOutput();
            }
        }


        /** Generates content based on window type. */
        function generateContent(config) {
            switch (config.type) {
                case 'terminal':
                    return `
                        <div id="terminal-output">
                            Welcome to <span class="text-cyan-400">GoreckiOS</span> web-desktop simulation.
                            <br>Type 'help' or any Linux command to interact with the LLM shell.
                            <br><br>
                        </div>
                        <div id="terminal-input-container">
                            <span class="prompt">${PROMPT_TEXT}</span>
                            <input id="terminal-input" type="text" autocomplete="off" onkeydown="handleCommand(event)" />
                        </div>
                    `;
                case 'text':
                    // Note: value is loaded dynamically during focusWindow
                    return `<textarea id="config-textarea" class="bg-transparent w-full h-full p-2 resize-none outline-none" placeholder="Loading content..."></textarea>`;
                case 'cmatrix-window':
                    return `<div class="cmatrix-container"><canvas id="matrix-canvas"></canvas></div>`;

                default:
                    return `<div class="p-2">Default window content.</div>`;
            }
        }

        /** Creates the HTML element for a window. */
        function createWindowEl(config, savedState = {}) {
            const windowEl = document.createElement('div');
            windowEl.id = config.id;
            windowEl.classList.add('i3-window', 'shadow-2xl', 'absolute'); 
            
            // Set up the internal data object
            let winData = { 
                el: windowEl, 
                config: { ...config, currentWorkspace: currentWorkspace }, // Add current workspace for tracking
                isFloating: savedState.isFloating !== undefined ? savedState.isFloating : config.isFloating, 
                // Restore lastMetrics or use a temporary placeholder
                lastMetrics: savedState.lastMetrics || {} 
            };
            
            // Handle content persistence initialization
            if (config.type === 'text') {
                if (savedState.content !== undefined) {
                    winData.config.content = savedState.content; 
                } else if (config.id === 'w2') {
                    // Use global config default on first creation
                    winData.config.content = configContent; 
                } else if (config.content) {
                    // Use config's default content
                    winData.config.content = config.content;
                } else {
                     winData.config.content = `[Window ${config.id}] Starting blank document on Workspace ${currentWorkspace}.`;
                }
            }


            // Special styling for the CMatrix window content (no padding)
            const contentClass = config.type === 'cmatrix-window' ? 'window-content p-0' : 'window-content';

            windowEl.innerHTML = `
                <div class="window-header" data-window-id="${config.id}">
                    <span class="window-title">${config.title}</span>
                    <div class="window-controls">
                        <button class="minimize-btn" title="Minimize" data-action="minimize"></button>
                        <button class="maximize-btn" title="Toggle Floating Mode" data-action="toggle-floating"></button>
                        <button class="close-btn" title="Close" data-action="close"></button>
                    </div>
                </div>
                <div class="${contentClass}">
                    ${generateContent(config)}
                </div>
            `;
            
            // Apply position and size based on saved state or tiling
            if (winData.isFloating && winData.lastMetrics.width) {
                applyMetrics(windowEl, winData.lastMetrics);
            } else {
                const metrics = calculateTiledMetrics(config.ratio);
                applyMetrics(windowEl, metrics);
                winData.lastMetrics = metrics; // Save initial tiled metrics
            }

            desktopEl.appendChild(windowEl);
            
            // Attach event listeners
            windowEl.addEventListener('mousedown', (e) => {
                focusWindow(windowEl);
            });
            // Also need to save state when window is resized via dragging
            windowEl.addEventListener('mouseup', saveState); 
            windowEl.querySelector('.window-header').addEventListener('mousedown', startDrag);
            windowEl.querySelectorAll('.window-controls button').forEach(button => {
                button.addEventListener('click', (e) => handleWindowControl(e, windowEl));
            });
            
            // Post-creation setup for CMatrix
            if (config.type === 'cmatrix-window') {
                const canvas = windowEl.querySelector('#matrix-canvas');
                if (canvas) {
                    // Initialize CMatrix (draw loop starts inside)
                    createMatrixEffect(canvas);
                }
            }

            return winData;
        }
        
        // --- Workspace Management ---
        function switchWorkspace(targetId) {
            if (targetId === currentWorkspace) return;

            // 1. Save the state of the currently focused window
            if (focusedWindow) {
                focusWindow(focusedWindow); // This triggers the save logic
            }

            // 2. Hide all currently visible windows
            windows.forEach(win => win.el.classList.add('hidden'));

            // 3. Update status bar styling
            const bar = getWorkspaceBar();
            bar.querySelectorAll('.workspace-btn').forEach(btn => {
                btn.classList.remove('bg-cyan-600', 'text-gray-900', 'font-bold');
                btn.classList.add('hover:bg-gray-700');
            });

            const newButton = bar.querySelector(`[data-workspace-id="${targetId}"]`);
            if (newButton) {
                newButton.classList.add('bg-cyan-600', 'text-gray-900', 'font-bold');
                newButton.classList.remove('hover:bg-gray-700');
            }

            // 4. Update current workspace and load/show new windows
            currentWorkspace = targetId;
            windows = []; // Reset the visible window array

            const configsToLoad = WORKSPACES[targetId] || [];

            configsToLoad.forEach(config => {
                let win = allWindows[config.id];
                
                // If window doesn't exist (first time on this workspace), create it
                if (!win) {
                    // Search if this window ID was used on another workspace
                    const existingConfig = Object.values(WORKSPACES).flat().find(c => c.id === config.id);
                    // Create from scratch if truly new
                    win = createWindowEl(existingConfig || config);
                    allWindows[config.id] = win;
                } 
                
                // Only show windows configured for the current workspace
                if (win.config.currentWorkspace === targetId) {
                    win.el.classList.remove('hidden');
                    windows.push(win); // Add to the visible list
                }
            });

            // 5. Retile the new set of visible windows
            tileWindows();

            // 6. Focus the terminal (w1) if on workspace 1, or the first window on others
            if (windows.length > 0) {
                 focusWindow(windows[0].el);
            } else {
                focusedWindow = null;
            }
        }
        
        function initWorkspaceListeners() {
            const bar = getWorkspaceBar();
            bar.addEventListener('click', (e) => {
                const targetId = e.target.getAttribute('data-workspace-id');
                if (targetId) {
                    switchWorkspace(targetId);
                }
            });
        }


        // --- Window Management and Drag/Drop ---
        function handleWindowControl(e, windowEl) {
            const action = e.target.getAttribute('data-action');
            const win = allWindows[windowEl.id];

            if (!win) return;
            e.stopPropagation();

            switch (action) {
                case 'close':
                    windowEl.classList.add('hidden');
                    // Remove from visible list so it's not tiled
                    windows = windows.filter(w => w.el.id !== windowEl.id); 
                    break;
                case 'minimize':
                    windowEl.classList.add('hidden');
                    break;
                case 'toggle-floating':
                    win.isFloating = !win.isFloating;
                    
                    // Temporarily remove transition for immediate visual change
                    windowEl.classList.add('no-transition');
                    
                    if (win.isFloating) {
                        // Save current tiled position as lastMetrics before floating
                        win.lastMetrics = { 
                            width: windowEl.offsetWidth, 
                            height: windowEl.offsetHeight,
                            left: windowEl.offsetLeft,
                            top: windowEl.offsetTop
                        };
                        
                        // Calculate a new centered floating position
                        const floatW = Math.max(desktopEl.clientWidth * 0.5, 400);
                        const floatH = Math.max(desktopEl.clientHeight * 0.6, 300);
                        const floatL = (desktopEl.clientWidth - floatW) / 2;
                        const floatT = (desktopEl.clientHeight - floatH) / 2;
                        
                        applyMetrics(windowEl, { left: floatL, top: floatT, width: floatW, height: floatH });
                        focusWindow(windowEl); 
                    } else {
                        // Return to the last calculated tiled position
                        const metrics = calculateTiledMetrics(win.config.ratio);
                        applyMetrics(windowEl, metrics);
                        win.lastMetrics = metrics;
                    }
                    
                    // Restore transition after a small timeout
                    setTimeout(() => {
                        windowEl.classList.remove('no-transition');
                        saveState(); // Save state after transition is done (or immediately)
                    }, 10);
                    break;
            }
            saveState();
        }

        function startDrag(e) {
            const headerEl = e.currentTarget;
            const windowEl = headerEl.closest('.i3-window');
            const win = allWindows[windowEl.id];

            if (!win || !win.isFloating) return; // Only allow drag on floating windows
            
            focusWindow(windowEl);
            isDragging = true;
            
            // Disable transitions during drag for smoothness
            windowEl.classList.add('no-transition');
            
            dragOffsetX = e.clientX - windowEl.offsetLeft;
            dragOffsetY = e.clientY - windowEl.offsetTop;

            windowEl.style.cursor = 'grabbing';
            headerEl.style.cursor = 'grabbing';
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            e.preventDefault(); 
        }

        function drag(e) {
            if (!isDragging || !focusedWindow) return;

            let newX = e.clientX - dragOffsetX;
            let newY = e.clientY - dragOffsetY;

            const maxLeft = desktopEl.clientWidth - focusedWindow.offsetWidth - GAP_SIZE;
            const maxTop = desktopEl.clientHeight - focusedWindow.offsetHeight - GAP_SIZE;

            newX = Math.max(GAP_SIZE, Math.min(newX, maxLeft));
            newY = Math.max(GAP_SIZE, Math.min(newY, maxTop));
            
            focusedWindow.style.left = `${newX}px`;
            focusedWindow.style.top = `${newY}px`;

            const win = allWindows[focusedWindow.id];
            if(win) {
                win.lastMetrics.left = newX;
                win.lastMetrics.top = newY;
            }
        }

        function endDrag() {
            if (!isDragging || !focusedWindow) return;

            isDragging = false;
            
            // Re-enable transitions after drag ends
            focusedWindow.classList.remove('no-transition');
            
            focusedWindow.style.cursor = 'default';
            focusedWindow.querySelector('.window-header').style.cursor = 'grab';

            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', endDrag);
            
            // Save final dragged position
            saveState();
        }

        // --- Initialization ---

        function initToneJs() {
            // Setup a simple synth for feedback
            successSynth = new Tone.Synth({
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.005,
                    decay: 0.1,
                    sustain: 0.01,
                    release: 0.1
                }
            }).toDestination();
        }

        /** Main initialization function, called after Firebase Auth is ready. */
        window.initDesktop = async function() {
            // 1. Initialize Tone.js for sounds
            initToneJs();

            // 2. Setup continuous time updates
            setInterval(updateDateTime, 1000);
            updateDateTime();
            
            let loadedStates = {};
            if (window.userId) {
                 // 3. Load persistent state from Firestore
                loadedStates = await loadState() || {};
            }
            
            // 4. Determine which workspace to start on (default 1)
            let initialWorkspace = '1';

            // 5. Create all windows configured in WORKSPACES, applying loaded state
            Object.keys(WORKSPACES).forEach(workspaceId => {
                WORKSPACES[workspaceId].forEach(config => {
                    const savedState = loadedStates[config.id] || {};
                    
                    // If window has saved state, update its current workspace tracker
                    if (savedState.currentWorkspace) {
                        config.currentWorkspace = savedState.currentWorkspace;
                        if (savedState.currentWorkspace !== workspaceId) return; // Skip creation if it belongs elsewhere
                    }

                    const win = createWindowEl(config, savedState);
                    allWindows[config.id] = win;
                });
            });
            
            // 6. Switch to the initial workspace
            switchWorkspace(initialWorkspace);

            // 7. Set up listeners for window resize and workspace bar
            window.addEventListener('resize', tileWindows);
            initWorkspaceListeners();

            // 8. Initial tile layout
            tileWindows();
        }
        
        // NOTE: Firebase initialization and calling initDesktop is handled 
        // in the <script type="module"> block above.
        
    </script>
</body>
</html>
